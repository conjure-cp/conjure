language Essence 1.4

letting RANGE be domain int(1..9)
letting VALUES be domain int(0..9)

given values : matrix indexed by [RANGE,RANGE] of VALUES

find field: matrix indexed by [RANGE, RANGE] of RANGE

$ find act1 : bool

$ neighbourhood row1 : (act1, [field[1,..]])

$ incumbentMapping ([field], [fieldshadow])

such that
  $ all rows have to be different
  forAll row : RANGE .
       allDiff(field[row,..]),

  $ all columns have to be different
  forAll col : RANGE .
       allDiff(field[..,col]),

  $ all 3x3 blocks have to be different
      forAll i,j : int(0..2) .
           forAll col1,col2,row1,row2 : int(1..3) .
           ((col1 != col2) /\ (row1 != row2)) ->
               (field[row1+(i*3), col1+(j*3)]
                                != field[row2+(i*3), col2+(j*3)]),

  $ we have to set some initial values
  forAll row,col : RANGE .
       (values[row,col] > 0) ->
               (field[row,col] = values[row,col]),


$ SNS stuff
  $ act1 -> true     $  any permutation of the first row is part of the 'hood.










neighbourhood row1
    using field[1,..]
    such that
        true

$ find activator_row1 : bool
$ find shadowOf_field : ...
$ such that activator_row1 -> true
$ neighbourhood row1 : (activator_row1, [field[1,..]])



neighbourhood row1FirstHalf
    using field[1,..]
    such that
        forAll i : int(1..5) . shadow(field[1,i]) = field[1,i]

$ find activator_row1FirstHalf : bool
$ find shadowOf_field : ...
$ such that activator_row1FirstHalf ->
$               forAll i : int(1..5) field[1,i] = shadowOf_field[1,i]
$ neighbourhood row1FirstHalf : (activator_row1FirstHalf, [field[1,..]])


$ incumbentMapping ([field], [shadowOf_field])



$ neighbourhood row1FirstHalf :
$      (forAll i : int(1..5) . shadow_field[1,i] = field[1,i]
$      ,
$      [field[1,..]]
$         )
$


