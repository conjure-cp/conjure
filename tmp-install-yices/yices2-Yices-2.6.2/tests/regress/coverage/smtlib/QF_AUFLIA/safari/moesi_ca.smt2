(set-logic QF_AUFLIA)
(set-info :source |
  These benchmarks come from SMT-queries of the infinite-state
  model-checking tool SAFARI (see SAFARI: SMT-based Abstraction
  For Arrays with Interpolants, by F. Alberti, R. Bruttomesso,
  S. Ghilardi, S. Ranise, and N. Sharygina, in CAV 2012).
  Each benchmark is a full trace resulting from the verification
  of a program manipulating arrays (e.g., find and element in an
  array, sort an array, etc.)
  Generated by Roberto Bruttomesso.
|)
(set-info :smt-lib-version 2.0)
(set-info :category "industrial")
; Declaring all variables
(declare-fun x () Int)
; success
(declare-fun j () Int)
; success
(declare-fun z0 () Int)
; success
(declare-fun z1 () Int)
; success
(declare-fun z2 () Int)
; success
(declare-fun z3 () Int)
; success
(declare-fun z4 () Int)
; success
(declare-fun z5 () Int)
; success
(declare-fun z6 () Int)
; success
(declare-fun z7 () Int)
; success
(declare-fun z8 () Int)
; success
(declare-fun z9 () Int)
; success
(declare-fun z10 () Int)
; success
; All INDEX variables are non-negative
(assert (<= 0 z0) )
; success
(assert (<= 0 z1) )
; success
(assert (<= 0 z2) )
; success
(assert (<= 0 z3) )
; success
(assert (<= 0 z4) )
; success
(assert (<= 0 z5) )
; success
(assert (<= 0 z6) )
; success
(assert (<= 0 z7) )
; success
(assert (<= 0 z8) )
; success
(assert (<= 0 z9) )
; success
(assert (<= 0 z10) )
; success
; All variables are different
(assert (not (= z0 z1)) )
; success
(assert (not (= z0 z2)) )
; success
(assert (not (= z0 z3)) )
; success
(assert (not (= z0 z4)) )
; success
(assert (not (= z0 z5)) )
; success
(assert (not (= z0 z6)) )
; success
(assert (not (= z0 z7)) )
; success
(assert (not (= z0 z8)) )
; success
(assert (not (= z0 z9)) )
; success
(assert (not (= z0 z10)) )
; success
(assert (not (= z1 z2)) )
; success
(assert (not (= z1 z3)) )
; success
(assert (not (= z1 z4)) )
; success
(assert (not (= z1 z5)) )
; success
(assert (not (= z1 z6)) )
; success
(assert (not (= z1 z7)) )
; success
(assert (not (= z1 z8)) )
; success
(assert (not (= z1 z9)) )
; success
(assert (not (= z1 z10)) )
; success
(assert (not (= z2 z3)) )
; success
(assert (not (= z2 z4)) )
; success
(assert (not (= z2 z5)) )
; success
(assert (not (= z2 z6)) )
; success
(assert (not (= z2 z7)) )
; success
(assert (not (= z2 z8)) )
; success
(assert (not (= z2 z9)) )
; success
(assert (not (= z2 z10)) )
; success
(assert (not (= z3 z4)) )
; success
(assert (not (= z3 z5)) )
; success
(assert (not (= z3 z6)) )
; success
(assert (not (= z3 z7)) )
; success
(assert (not (= z3 z8)) )
; success
(assert (not (= z3 z9)) )
; success
(assert (not (= z3 z10)) )
; success
(assert (not (= z4 z5)) )
; success
(assert (not (= z4 z6)) )
; success
(assert (not (= z4 z7)) )
; success
(assert (not (= z4 z8)) )
; success
(assert (not (= z4 z9)) )
; success
(assert (not (= z4 z10)) )
; success
(assert (not (= z5 z6)) )
; success
(assert (not (= z5 z7)) )
; success
(assert (not (= z5 z8)) )
; success
(assert (not (= z5 z9)) )
; success
(assert (not (= z5 z10)) )
; success
(assert (not (= z6 z7)) )
; success
(assert (not (= z6 z8)) )
; success
(assert (not (= z6 z9)) )
; success
(assert (not (= z6 z10)) )
; success
(assert (not (= z7 z8)) )
; success
(assert (not (= z7 z9)) )
; success
(assert (not (= z7 z10)) )
; success
(assert (not (= z8 z9)) )
; success
(assert (not (= z8 z10)) )
; success
(assert (not (= z9 z10)) )
; success
; Declaring non INDEX variables
; Declaring scalar variables
; Declaring array variables
(declare-fun a () (Array Int Int))
; success
(declare-fun m () (Array Int Int))
; success
(declare-fun e () (Array Int Int))
; success
(declare-fun i () (Array Int Int))
; success
(declare-fun s () (Array Int Int))
; success
(declare-fun o () (Array Int Int))
; success
; Asserting 'globality' of some arrays
; Asserting system axiom
(assert (<= 0 (select m z0)) )
; success
(assert (<= 0 (select m z1)) )
; success
(assert (<= 0 (select m z2)) )
; success
(assert (<= 0 (select m z3)) )
; success
(assert (<= 0 (select m z4)) )
; success
(assert (<= 0 (select m z5)) )
; success
(assert (<= 0 (select m z6)) )
; success
(assert (<= 0 (select m z7)) )
; success
(assert (<= 0 (select m z8)) )
; success
(assert (<= 0 (select m z9)) )
; success
(assert (<= 0 (select m z10)) )
; success
; Asserting system axiom
(assert (<= 0 (select e z0)) )
; success
(assert (<= 0 (select e z1)) )
; success
(assert (<= 0 (select e z2)) )
; success
(assert (<= 0 (select e z3)) )
; success
(assert (<= 0 (select e z4)) )
; success
(assert (<= 0 (select e z5)) )
; success
(assert (<= 0 (select e z6)) )
; success
(assert (<= 0 (select e z7)) )
; success
(assert (<= 0 (select e z8)) )
; success
(assert (<= 0 (select e z9)) )
; success
(assert (<= 0 (select e z10)) )
; success
; Asserting system axiom
(assert (<= 0 (select i z0)) )
; success
(assert (<= 0 (select i z1)) )
; success
(assert (<= 0 (select i z2)) )
; success
(assert (<= 0 (select i z3)) )
; success
(assert (<= 0 (select i z4)) )
; success
(assert (<= 0 (select i z5)) )
; success
(assert (<= 0 (select i z6)) )
; success
(assert (<= 0 (select i z7)) )
; success
(assert (<= 0 (select i z8)) )
; success
(assert (<= 0 (select i z9)) )
; success
(assert (<= 0 (select i z10)) )
; success
; Asserting system axiom
(assert (<= 0 (select s z0)) )
; success
(assert (<= 0 (select s z1)) )
; success
(assert (<= 0 (select s z2)) )
; success
(assert (<= 0 (select s z3)) )
; success
(assert (<= 0 (select s z4)) )
; success
(assert (<= 0 (select s z5)) )
; success
(assert (<= 0 (select s z6)) )
; success
(assert (<= 0 (select s z7)) )
; success
(assert (<= 0 (select s z8)) )
; success
(assert (<= 0 (select s z9)) )
; success
(assert (<= 0 (select s z10)) )
; success
; Asserting system axiom
(assert (<= 0 (select o z0)) )
; success
(assert (<= 0 (select o z1)) )
; success
(assert (<= 0 (select o z2)) )
; success
(assert (<= 0 (select o z3)) )
; success
(assert (<= 0 (select o z4)) )
; success
(assert (<= 0 (select o z5)) )
; success
(assert (<= 0 (select o z6)) )
; success
(assert (<= 0 (select o z7)) )
; success
(assert (<= 0 (select o z8)) )
; success
(assert (<= 0 (select o z9)) )
; success
(assert (<= 0 (select o z10)) )
; success
(set-info :status sat)
(check-sat)
; sat
(push 1)
; success
(define-fun Initial ((x Int)) Bool (and (= (select m x) 0) (= (select e x) 0) (= (select s x) 0) (= (select o x) 0)))
; success
(define-fun Node0_0 ((z0 Int)) Bool (and (= (select a z0) 1) (not (<= (select m z0) 1))) )
; success
(push 1)
; success
; 
; 
; 
; Check initial intersection
(push 1)
; success
(assert (and (= (select a z0) 1) (not (<= (select m z0) 1))) )
; success
(assert (Initial z0 ) )
; success
(set-info :status unsat)
(check-sat)
; unsat
(pop 1)
; success
; 
; 
; Fixpoint test starts (c3)
(push 1)
; success
; Asserting the label of the node
(assert (and (= (select a z0) 1) (not (<= (select m z0) 1))) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; End fixpoint check
; 
; 
; Checking if the new preimage computed from node 0 with t0(z0) is safe
(push 1)
; success
(assert (and (= (select a z0) 1) (not (<= (+ (select m z0) 1) 1)) (not (<= (select e z0) 0))) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; Checking if the new preimage computed from node 0 with t1(z0) is safe
; Checking if the new preimage computed from node 0 with t2(z0) is safe
; Checking if the new preimage computed from node 0 with t3(z0) is safe
; Checking if the new preimage computed from node 0 with t4(z0) is safe
; 
; 
; Fixpoint test starts (2)
(push 1)
; success
; Asserting the label of the node
(assert (and (= (select a z0) 1) (not (<= (+ (select m z0) 1) 1)) (not (<= (select e z0) 0))) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; End fixpoint check
; 
; 
; 
; 
; Fixpoint test starts (c3)
(push 1)
; success
; Asserting the label of the node
(assert (and (= (select a z0) 1) (not (<= (+ (select m z0) 1) 1)) (not (<= (select e z0) 0))) )
; success
(assert (not (Node0_0 z0 )) )
; success
(assert (not (Node0_0 z0 )) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; End fixpoint check
; 
; 
; 
; 
; 
; 
; 
; Defining new node derived from node 0 applying transition 0
(define-fun Node1_0 ((z0 Int)) Bool (and (= (select a z0) 1) (not (<= (+ (select m z0) 1) 1)) (not (<= (select e z0) 0))) )
; success
; 
; 
; 
; Check initial intersection
(push 1)
; success
(assert (and (= (select a z0) 1) (not (<= (+ (select m z0) 1) 1)) (not (<= (select e z0) 0))) )
; success
(assert (Initial z0 ) )
; success
(set-info :status unsat)
(check-sat)
; unsat
(pop 1)
; success
; 
; 
; Fixpoint test starts (c3)
(push 1)
; success
; Asserting the label of the node
(assert (and (= (select a z0) 1) (not (<= (+ (select m z0) 1) 1)) (not (<= (select e z0) 0))) )
; success
(assert (not (Node0_0 z0 )) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; End fixpoint check
; 
; 
; Checking if the new preimage computed from node 1 with t0(z0) is safe
(push 1)
; success
(assert (and (= (select a z0) 1) (not (<= (select e z0) 0)) (not (<= (+ (+ (select m z0) 1) 1) 1)) (not (<= (+ (select e z0) (- 1)) 0))) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; Checking if the new preimage computed from node 1 with t1(z0) is safe
; Checking if the new preimage computed from node 1 with t2(z0) is safe
; Checking if the new preimage computed from node 1 with t3(z0) is safe
; Checking if the new preimage computed from node 1 with t4(z0) is safe
; 
; 
; Fixpoint test starts (2)
(push 1)
; success
; Asserting the label of the node
(assert (and (= (select a z0) 1) (not (<= (select e z0) 0)) (not (<= (+ (+ (select m z0) 1) 1) 1)) (not (<= (+ (select e z0) (- 1)) 0))) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; End fixpoint check
; 
; 
; 
; 
; Fixpoint test starts (c3)
(push 1)
; success
; Asserting the label of the node
(assert (and (= (select a z0) 1) (not (<= (select e z0) 0)) (not (<= (+ (+ (select m z0) 1) 1) 1)) (not (<= (+ (select e z0) (- 1)) 0))) )
; success
(assert (not (Node0_0 z0 )) )
; success
(assert (not (Node1_0 z0 )) )
; success
(assert (not (Node1_0 z0 )) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; End fixpoint check
; 
; 
; 
; 
; 
; 
; 
; Defining new node derived from node 1 applying transition 0
(define-fun Node2_0 ((z0 Int)) Bool (and (= (select a z0) 1) (not (<= (select e z0) 0)) (not (<= (+ (+ (select m z0) 1) 1) 1)) (not (<= (+ (select e z0) (- 1)) 0))) )
; success
; 
; 
; 
; Check initial intersection
(push 1)
; success
(assert (and (= (select a z0) 1) (not (<= (select e z0) 0)) (not (<= (+ (+ (select m z0) 1) 1) 1)) (not (<= (+ (select e z0) (- 1)) 0))) )
; success
(assert (Initial z0 ) )
; success
(set-info :status unsat)
(check-sat)
; unsat
(pop 1)
; success
; 
; 
; Fixpoint test starts (c3)
(push 1)
; success
; Asserting the label of the node
(assert (and (= (select a z0) 1) (not (<= (select e z0) 0)) (not (<= (+ (+ (select m z0) 1) 1) 1)) (not (<= (+ (select e z0) (- 1)) 0))) )
; success
(assert (not (Node0_0 z0 )) )
; success
(assert (not (Node1_0 z0 )) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; End fixpoint check
; 
; 
; Checking if the new preimage computed from node 2 with t0(z0) is safe
(push 1)
; success
(assert (and (= (select a z0) 1) (not (<= (+ (+ (+ (select m z0) 1) 1) 1) 1)) (not (<= (select e z0) 0)) (not (<= (+ (+ (select e z0) (- 1)) (- 1)) 0)) (not (<= (+ (select e z0) (- 1)) 0))) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; Checking if the new preimage computed from node 2 with t1(z0) is safe
; Checking if the new preimage computed from node 2 with t2(z0) is safe
; Checking if the new preimage computed from node 2 with t3(z0) is safe
; Checking if the new preimage computed from node 2 with t4(z0) is safe
; 
; 
; Fixpoint test starts (2)
(push 1)
; success
; Asserting the label of the node
(assert (and (= (select a z0) 1) (not (<= (+ (+ (+ (select m z0) 1) 1) 1) 1)) (not (<= (select e z0) 0)) (not (<= (+ (+ (select e z0) (- 1)) (- 1)) 0)) (not (<= (+ (select e z0) (- 1)) 0))) )
; success
(set-info :status sat)
(check-sat)
; sat
(pop 1)
; success
; End fixpoint check
; 
; 
; 
; 
; Fixpoint test starts (c3)
(push 1)
; success
; Asserting the label of the node
(assert (and (= (select a z0) 1) (not (<= (+ (+ (+ (select m z0) 1) 1) 1) 1)) (not (<= (select e z0) 0)) (not (<= (+ (+ (select e z0) (- 1)) (- 1)) 0)) (not (<= (+ (select e z0) (- 1)) 0))) )
; success
(assert (not (Node0_0 z0 )) )
; success
(assert (not (Node1_0 z0 )) )
; success
(assert (not (Node2_0 z0 )) )
; success
(assert (not (Node2_0 z0 )) )
; success
(set-info :status unsat)
(check-sat)
; unsat
(pop 1)
; success
; End fixpoint check
(pop 1)
; success
(pop 1)
; success
(exit)
